/*
 * THIS FILE WAS GENERATED BY PLOTLY.BLAZOR.GENERATOR
*/

using System.Text.Json.Serialization;
using System.Collections.Generic;
using Plotly.Blazor.Transforms.AggregateLib.AggregationLib;

namespace Plotly.Blazor.Transforms.AggregateLib
{
    /// <summary>
    ///     The Aggregation class.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("Plotly.Blazor.Generator", "1.0.0.0")]
    public class Aggregation 
    {
        /// <summary>
        ///     A reference to the data array in the parent trace to aggregate. To aggregate
        ///     by nested variables, use *.* to access them. For example, set `groups` to
        ///     *marker.color* to aggregate over the marker color array. The referenced
        ///     array must already exist, unless `func` is *count*, and each array may only
        ///     be referenced once.
        /// </summary>
        [JsonPropertyName(@"target")]
        public string Target { get; set;} 

        /// <summary>
        ///     Sets the aggregation function. All values from the linked `target`, corresponding
        ///     to the same value in the `groups` array, are collected and reduced by this
        ///     function. *count* is simply the number of values in the `groups` array,
        ///     so does not even require the linked array to exist. *first* (*last*) is
        ///     just the first (last) linked value. Invalid values are ignored, so for example
        ///     in *avg* they do not contribute to either the numerator or the denominator.
        ///     Any data type (numeric, date, category) may be aggregated with any function,
        ///     even though in certain cases it is unlikely to make sense, for example a
        ///     sum of dates or average of categories. *median* will return the average
        ///     of the two central values if there is an even count. *mode* will return
        ///     the first value to reach the maximum count, in case of a tie. *change* will
        ///     return the difference between the first and last linked values. *range*
        ///     will return the difference between the min and max linked values.
        /// </summary>
        [JsonPropertyName(@"func")]
        public FuncEnum? Func { get; set;} 

        /// <summary>
        ///     *stddev* supports two formula variants: *sample* (normalize by N-1) and
        ///     *population* (normalize by N).
        /// </summary>
        [JsonPropertyName(@"funcmode")]
        public FuncModeEnum? FuncMode { get; set;} 

        /// <summary>
        ///     Determines whether this aggregation function is enabled or disabled.
        /// </summary>
        [JsonPropertyName(@"enabled")]
        public bool? Enabled { get; set;} 

    }
}